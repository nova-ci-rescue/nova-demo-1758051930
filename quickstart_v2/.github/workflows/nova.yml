# yamllint disable rule:document-start rule:line-length rule:truthy rule:comments-indentation
name: Nova CI-Rescue

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write
  checks: write

defaults:
  run:
    shell: bash

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}-nova-demo
  cancel-in-progress: true

jobs:
  nova:
    name: nova
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: ${{ !(github.event_name == 'push' && (contains(github.event.head_commit.message, '[skip nova]') || contains(github.event.head_commit.message, 'Nova Auto-Fix'))) }}
    env:
      # Prefer nova-bot PAT when present; otherwise use repo's GITHUB_TOKEN
      GH_TOKEN: ${{ secrets.NOVA_BOT_TOKEN != '' && secrets.NOVA_BOT_TOKEN || secrets.GITHUB_TOKEN }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ github.token }}
          persist-credentials: true
          ref: ${{ github.event.pull_request.head.ref || github.ref }}

      - name: Ensure config exists
        run: |
          test -f .nova-ci/config.json || { echo "::error::Missing .nova-ci/config.json"; exit 1; }
          echo "Config OK"

      - name: Read config
        id: cfg
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const cfg = JSON.parse(fs.readFileSync('.nova-ci/config.json','utf8'));
            const out = (k,v)=>core.setOutput(k, String(v));

            out('LANG', (cfg.language || 'python'));
            out('INSTALL', (cfg.install || []).join(' && ').replace(/\n/g,' '));
            out('TEST_CMD', (cfg.test_command || 'pytest -q'));
            out('BRAND_NAME', (cfg.brand?.name || 'CI Pipeline'));

            const nova = (cfg.nova || {});
            out('NOVA_PKG', (nova.package || 'nova-ci-rescue'));
            out('NOVA_IDX', (nova.index_url || ''));
            out('NOVA_VER', (nova.version || ''));
            out('NOVA_ARGS', (nova.fix_args || '--ci-mode --patch-mode --timeout 900'));

            const safety = (nova.safety_env || {});
            for (const [k,v] of Object.entries(safety)) core.setOutput(k, String(v));
          result-encoding: string

      - name: Start timer
        id: t0
        run: |
          TS=$(date +%s)
          echo "ts=$TS" >> "$GITHUB_OUTPUT"
          echo "NOVA_START_TS=$TS" >> "$GITHUB_ENV"

      - name: Ensure dependency manifest (for Python cache compatibility)
        run: |
          if [ ! -f requirements.txt ] && [ ! -f pyproject.toml ]; then
            echo "pytest" > requirements.txt
            echo "pytest-json-report" >> requirements.txt
            echo "pytest-metadata" >> requirements.txt
            echo "numpy" >> requirements.txt
            echo "Created minimal requirements.txt to satisfy tooling"
          fi

      - name: Set up Python (Nova CLI is Python)
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: YAML lint (yamllint)
        run: |
          python -m pip install -U yamllint
          yamllint -f colored -s .github/workflows/nova.yml

      - name: Language runtime (Node optional)
        if: ${{ steps.cfg.outputs.LANG == 'node' }}
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install project deps
        if: ${{ steps.cfg.outputs.INSTALL != '' }}
        run: bash -lc '${{ steps.cfg.outputs.INSTALL }}'

      - name: Install project requirements (if present)
        if: ${{ hashFiles('requirements.txt') != '' }}
        run: |
          python -m pip install -U pip
          python -m pip install -U nova-ci-rescue || python -m pip install -U nova_ci_rescue || true
          pip install -r requirements.txt

      - name: Install minimal test deps (always)
        run: |
          python -m pip install -U pip pytest pytest-json-report pytest-metadata pytest-json-report

      # Skip installing the repo as an editable package. We rely on PYTHONPATH for imports.

      - name: Ensure pytest config & PYTHONPATH
        run: |
          if [ ! -f pytest.ini ]; then
            printf "[pytest]\ntestpaths = tests\n" > pytest.ini
          fi
          echo "PYTHONPATH=." >> $GITHUB_ENV

      - name: "Smoke: list tests (do not fail job)"
        continue-on-error: true
        env:
          PYTHONPATH: ${{ env.PYTHONPATH }}
        run: |
          PYTHONPATH=. python -m pytest --collect-only -q || true

      - name: Pre-scan tests (fast + robust)
        id: pre
        timeout-minutes: 6
        env:
          PYTHONPATH: .:./src
          PYTEST_DISABLE_PLUGIN_AUTOLOAD: 1
        run: |
          set +e
          # Quick probe: find at least one failure fast, but still emit JSON
          timeout 300s python -m pytest -q \
            -p pytest_jsonreport \
            --maxfail=1 \
            --tb=short -rN \
            -k 'not slow and not e2e' \
            --json-report \
            --json-report-file=test-results.json \
            --junit-xml=junit-pre.xml
          EC=$?

          # Ensure a JSON file exists even if pytest was killed before writing one
          if [ ! -s test-results.json ]; then
            echo '{"summary":{"failed":0,"errors":0},"tests":[]}' > test-results.json
          fi

          # Parse counts (works whether plugin wrote summary or only per-test entries)
          FAILS=$(jq -r '.summary.failed // (.tests|map(select(.outcome=="failed"))|length) // 0' test-results.json 2>/dev/null || echo 0)
          ERRORS=$(jq -r '.summary.errors // (.tests|map(select(.outcome=="error"))|length) // 0' test-results.json 2>/dev/null || echo 0)

          echo "PYTEST_EXIT=$EC" >> "$GITHUB_ENV"
          echo "failures=$FAILS"  >> "$GITHUB_OUTPUT"
          echo "errors=$ERRORS"   >> "$GITHUB_OUTPUT"
          echo "exit=$EC"         >> "$GITHUB_OUTPUT"
          echo "Pre-scan: failures=${FAILS}, errors=${ERRORS}, exit=${EC}"
          set -e

      - name: Upload pre-scan results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pre-scan-artifacts-${{ github.run_id }}
          path: test-results.json
          if-no-files-found: ignore

      # ────────────────────────────────────────────────────────────────────────────
      # One sticky PR comment that we update throughout the job
      # ────────────────────────────────────────────────────────────────────────────

      - name: Sticky PR status (init)
        if: ${{ github.event_name == 'pull_request' && (steps.pre.outputs.failures != '0' || steps.pre.outputs.errors != '0') }}
        id: sticky_init
        uses: actions/github-script@v7
        env:
          PRE_FAILED: ${{ steps.pre.outputs.failures || '0' }}
        with:
          script: |
            const anchor = '<!-- NOVA_STICKY_COMMENT -->';
            const status = `🟡 Running (iteration 1/3)`;
            const failing = process.env.PRE_FAILED || '0';
            const line = `Failing tests: ${failing} → — • Patch size: — • Elapsed: 0s`;
            const body = [
              anchor,
              '## 🤖 Nova CI‑Rescue',
              '',
              `Status: ${status}`,
              line,
              '',
              '<details><summary>Artifacts & links</summary>',
              `- CI run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              '- Patch/diff: (will appear after first commit)',
              '- Logs: see workflow artifacts',
              '</details>',
              '',
              'Guardrails: ≤40 LOC · ≤5 files · ≤3 attempts · never touches `main`',
            ].join('\n');

            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const mine = comments.find(c => (c.body||'').includes(anchor));
            if (mine) {
              await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body});
              core.setOutput('comment_id', String(mine.id));
            } else {
              const {data} = await github.rest.issues.createComment({owner, repo, issue_number, body});
              core.setOutput('comment_id', String(data.id));
            }

      - name: "Label: in-progress"
        if: ${{ github.event_name == 'pull_request' && (steps.pre.outputs.failures != '0' || steps.pre.outputs.errors != '0') }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            try {
              const {data} = await github.rest.issues.listLabelsOnIssue({owner, repo, issue_number});
              for (const L of data) if (L.name && L.name.startsWith('nova-')) {
                await github.rest.issues.removeLabel({owner, repo, issue_number, name: L.name}).catch(()=>{});
              }
            } catch {}
            await github.rest.issues.addLabels({owner, repo, issue_number, labels: ['nova-in-progress']});

      - name: "PR description: bug details"
        if: ${{ github.event_name == 'pull_request' }}
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pull_number = context.issue.number || context.payload.pull_request.number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number });
            const header = '### Bug details';
            const bullets = [
              '- Zero-score documents were previously filtered out; they must be kept.',
              '- Sort results by score descending; tie-break with index ascending.',
              '- Return exactly min(k, len(corpus)) using slice [:k] (fix off-by-one).'
            ].join('\n');
            const block = `${header}\n\n${bullets}`;
            const body = (pr.body || '').trim();
            if (!body.includes(header)) {
              const newBody = (body ? body + '\n\n' : '') + block;
              await github.rest.pulls.update({ owner, repo, pull_number, body: newBody });
            }

      - name: Install Nova (Cloudsmith latest or pinned)
        if: ${{ steps.pre.outputs.failures != '0' || steps.pre.outputs.errors != '0' || env.PYTEST_EXIT != '0' || steps.pre.outputs.exit != '0' }}
        run: |
          PKG="${{ steps.cfg.outputs.NOVA_PKG }}${{ steps.cfg.outputs.NOVA_VER }}"
          INDEX="${{ steps.cfg.outputs.NOVA_IDX }}"
          python -m pip install -U pip
          if [ -n "$INDEX" ]; then
            python -m pip install -U --no-cache-dir "$PKG" \
              --index-url "$INDEX" --extra-index-url https://pypi.org/simple/
          else
            python -m pip install -U --no-cache-dir "$PKG"
          fi

      - name: Sticky → planned
        if: ${{ github.event_name == 'pull_request' && (steps.pre.outputs.failures != '0' || steps.pre.outputs.errors != '0') }}
        uses: actions/github-script@v7
        env:
          START_TS: ${{ steps.t0.outputs.ts }}
        with:
          script: |
            const anchor = '<!-- NOVA_STICKY_COMMENT -->';
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const mine = comments.find(c => (c.body||'').includes(anchor));
            if (!mine) return;

            const hms = s => `${Math.floor(s/60)}m ${s%60}s`;
            const elapsed = hms(Math.max(0, Math.floor(Date.now()/1000 - Number(process.env.START_TS||0))));

            let body = (mine.body||'')
              .replace(/Status: .*/, 'Status: 🧠 Planned fix, generating patch…')
              .replace(/• Elapsed: [^\n]*/, '• Elapsed: ' + elapsed);
            await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body});

      - name: Configure Git user
        if: ${{ steps.pre.outputs.failures != '0' || steps.pre.outputs.errors != '0' }}
        run: |
          git config user.name "nova-bot"
          git config user.email "nova@ci-auto-rescue.dev"
          git config --global push.autoSetupRemote true

      # Only run Nova if there are any failing tests OR collection/import errors
      - name: Run Nova auto-fix
        if: ${{ steps.pre.outputs.failures != '0' || steps.pre.outputs.errors != '0' || env.PYTEST_EXIT != '0' || steps.pre.outputs.exit != '0' }}
        id: nova
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PYTHONPATH: .
          GH_TOKEN: ${{ env.GH_TOKEN }}
          GITHUB_TOKEN: ${{ github.token }}
          NOVA_SAFETY_MAX_FILES: ${{ steps.cfg.outputs.NOVA_SAFETY_MAX_FILES }}
          NOVA_SAFETY_MAX_LINES_PER_FILE: ${{ steps.cfg.outputs.NOVA_SAFETY_MAX_LINES_PER_FILE }}
        run: |
          set -e
          echo "Running Nova because pre-scan found failures/errors…"
          nova --version
          START=$(date +%s)
          BEFORE_SHA=$(git rev-parse HEAD 2>/dev/null || echo "")
          nova fix . --ci-mode --patch-mode --timeout 900 --verbose --max-iters 3
          END=$(date +%s)
          AFTER_SHA=$(git rev-parse HEAD 2>/dev/null || echo "")
          echo "duration=$((END-START))s" >> "$GITHUB_OUTPUT"
          echo "nova_exit=0" >> "$GITHUB_OUTPUT"

          # Gather patch stats and commit ONLY source changes (never .nova)
          if [ -n "$BEFORE_SHA" ] && [ -n "$AFTER_SHA" ] && [ "$BEFORE_SHA" != "$AFTER_SHA" ]; then
            # Nova committed directly; compute stats from commit range
            mkdir -p .nova
            FILES=$(git diff --name-only "$BEFORE_SHA".."$AFTER_SHA" | wc -l | xargs)
            ADDED=$(git diff --numstat "$BEFORE_SHA".."$AFTER_SHA" | awk '{a+=$1} END{print a+0}')
            REMOVED=$(git diff --numstat "$BEFORE_SHA".."$AFTER_SHA" | awk '{r+=$2} END{print r+0}')
            printf '{"files_changed": %s, "lines_added": %s, "lines_removed": %s}\n' "${FILES:-0}" "${ADDED:-0}" "${REMOVED:-0}" > .nova/changes.json
            [ -f .nova/plan.md ] || echo "No detailed plan was provided by Nova." > .nova/plan.md
            # Force pushes to use the workflow token
            git config --local http.https://github.com/.extraheader "AUTHORIZATION: basic $(printf "x-access-token:%s" "$GITHUB_TOKEN" | base64 -w 0 2>/dev/null || printf "x-access-token:%s" "$GITHUB_TOKEN" | base64)"
            BRANCH="${{ github.event.pull_request.head.ref || github.ref_name }}"
            [ -z "$BRANCH" -o "$BRANCH" = "refs/heads/" ] && BRANCH="$(git rev-parse --abbrev-ref HEAD)"
            git push --set-upstream origin "HEAD:$BRANCH" || { echo "::error::Push failed (403). Check token permissions or branch protections."; exit 1; }
            echo "changes_made=true"            >> "$GITHUB_OUTPUT"
            echo "files_changed=$FILES"         >> "$GITHUB_OUTPUT"
            echo "lines_added=$ADDED"           >> "$GITHUB_OUTPUT"
            echo "lines_removed=$REMOVED"       >> "$GITHUB_OUTPUT"
          else
            # Fallback: stage and commit any uncommitted changes made by this job
            if [ -n "$(git status --porcelain)" ]; then
              mkdir -p .nova
              git add -A
              git reset .nova 2>/dev/null || true
              FILES=$(git diff --cached --name-only | wc -l | xargs)
              ADDED=$(git diff --cached --numstat | awk '{a+=$1} END{print a+0}')
              REMOVED=$(git diff --cached --numstat | awk '{r+=$2} END{print r+0}')
              printf '{"files_changed": %s, "lines_added": %s, "lines_removed": %s}\n' "${FILES:-0}" "${ADDED:-0}" "${REMOVED:-0}" > .nova/changes.json
              [ -f .nova/plan.md ] || echo "No detailed plan was provided by Nova." > .nova/plan.md
              git commit -m "Nova Auto-Fix: make tests pass [skip nova]"
              BRANCH="${{ github.event.pull_request.head.ref || github.ref_name }}"
              [ -z "$BRANCH" -o "$BRANCH" = "refs/heads/" ] && BRANCH="$(git rev-parse --abbrev-ref HEAD)"
              # Force pushes to use the workflow token
              git config --local http.https://github.com/.extraheader "AUTHORIZATION: basic $(printf "x-access-token:%s" "$GITHUB_TOKEN" | base64 -w 0 2>/dev/null || printf "x-access-token:%s" "$GITHUB_TOKEN" | base64)"
              git push --set-upstream origin "HEAD:$BRANCH" || { echo "::error::Push failed (403). Check token permissions or branch protections."; exit 1; }
              echo "changes_made=true"            >> "$GITHUB_OUTPUT"
              echo "files_changed=$FILES"         >> "$GITHUB_OUTPUT"
              echo "lines_added=$ADDED"           >> "$GITHUB_OUTPUT"
              echo "lines_removed=$REMOVED"       >> "$GITHUB_OUTPUT"
            else
              echo "changes_made=false"           >> "$GITHUB_OUTPUT"
              echo "files_changed=0"              >> "$GITHUB_OUTPUT"
              echo "lines_added=0"                >> "$GITHUB_OUTPUT"
              echo "lines_removed=0"              >> "$GITHUB_OUTPUT"
            fi
          fi

      # If Nova didn't run (already green), say so explicitly to avoid "stuck" UX
      - name: Skip notice (already green)
        if: ${{ steps.pre.outputs.failures == '0' && steps.pre.outputs.errors == '0' }}
        run: echo "Pre-scan found no failing tests. Skipping Nova (repo is green)."

      - name: Sticky → re‑running tests (with plan + elapsed + LOC)
        if: ${{ github.event_name == 'pull_request' && (steps.pre.outputs.failures != '0' || steps.pre.outputs.errors != '0') }}
        uses: actions/github-script@v7
        env:
          START_TS: ${{ steps.t0.outputs.ts }}
          LINES_ADDED: ${{ steps.nova.outputs.lines_added || '0' }}
          LINES_REMOVED: ${{ steps.nova.outputs.lines_removed || '0' }}
        with:
          script: |
            const anchor = '<!-- NOVA_STICKY_COMMENT -->';
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const mine = comments.find(c => (c.body||'').includes(anchor));
            if (!mine) return;

            const hms = s => `${Math.floor(s/60)}m ${s%60}s`;
            const elapsed = hms(Math.max(0, Math.floor(Date.now()/1000 - Number(process.env.START_TS||0))));
            const loc = (Number(process.env.LINES_ADDED||0) + Number(process.env.LINES_REMOVED||0)) + ' LOC';

            const fs = require('fs');
            let body = (mine.body||'')
              .replace(/Status: .*/, 'Status: 🧪 Re‑running tests…')
              .replace(/Patch size: [^•\n]*/, 'Patch size: ' + loc)
              .replace(/• Elapsed: [^\n]*/, '• Elapsed: ' + elapsed);

            // Removed Plan append
            await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body});

      - name: Verify tests after fix
        if: ${{ steps.nova.outputs.changes_made == 'true' }}
        id: test_post
        continue-on-error: true
        timeout-minutes: 3
        env:
          PYTHONPATH: ${{ env.PYTHONPATH }}
        run: |
          set +e
          timeout 120 python -m pytest -q \
            --json-report \
            --json-report-file=test-results-after.json \
            --junit-xml=junit-after.xml \
            --tb=no \
            --maxfail=10 \
            -x || true
          CODE=$?
          echo "exit_code=$CODE" >> "$GITHUB_OUTPUT"
          if [ -f test-results-after.json ]; then
            FAILS=$(jq -r '.summary.failed' test-results-after.json 2>/dev/null || echo "")
          fi
          echo "failed=${FAILS:-}" >> "$GITHUB_OUTPUT"
          set -e

      - name: Sticky → success
        if: ${{ github.event_name == 'pull_request' && steps.nova.outputs.changes_made == 'true' && steps.test_post.outputs.exit_code == '0' }}
        uses: actions/github-script@v7
        env:
          START_TS: ${{ steps.t0.outputs.ts }}
          PRE_FAILED: ${{ steps.test_pre.outputs.pre_failed || '0' }}
          LINES_ADDED: ${{ steps.nova.outputs.lines_added || '0' }}
          LINES_REMOVED: ${{ steps.nova.outputs.lines_removed || '0' }}
        with:
          script: |
            const anchor = '<!-- NOVA_STICKY_COMMENT -->';
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const mine = comments.find(c => (c.body||'').includes(anchor));
            if (!mine) return;

            const hms = s => `${Math.floor(s/60)}m ${s%60}s`;
            const elapsed = hms(Math.max(0, Math.floor(Date.now()/1000 - Number(process.env.START_TS||0))));
            const loc = (Number(process.env.LINES_ADDED||0) + Number(process.env.LINES_REMOVED||0)) + ' LOC';
            const pre = process.env.PRE_FAILED || '0';

            const body = (mine.body||'')
              .replace(/Status: .*/, 'Status: ✅ All tests passing')
              .replace(/Failing tests: .*/, `Failing tests: ${pre} → 0 • Patch size: ${loc} • Elapsed: ${elapsed}`);
            await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body});

      - name: "Label: fixed"
        if: ${{ github.event_name == 'pull_request' && steps.nova.outputs.changes_made == 'true' && steps.test_post.outputs.exit_code == '0' }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            try {
              const {data} = await github.rest.issues.listLabelsOnIssue({owner, repo, issue_number});
              for (const L of data) if (L.name.startsWith('nova-')) await github.rest.issues.removeLabel({owner, repo, issue_number, name: L.name}).catch(()=>{});
            } catch {}
            await github.rest.issues.addLabels({owner, repo, issue_number, labels: ['nova-fixed']});

      - name: Sticky → partial
        if: ${{ github.event_name == 'pull_request' && steps.nova.outputs.changes_made == 'true' && steps.test_post.outputs.exit_code != '0' }}
        uses: actions/github-script@v7
        env:
          START_TS: ${{ steps.t0.outputs.ts }}
          PRE_FAILED: ${{ steps.test_pre.outputs.pre_failed || '0' }}
          POST_FAILED: ${{ steps.test_post.outputs.failed || '—' }}
          LINES_ADDED: ${{ steps.nova.outputs.lines_added || '0' }}
          LINES_REMOVED: ${{ steps.nova.outputs.lines_removed || '0' }}
        with:
          script: |
            const anchor = '<!-- NOVA_STICKY_COMMENT -->';
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const mine = comments.find(c => (c.body||'').includes(anchor));
            if (!mine) return;

            const hms = s => `${Math.floor(s/60)}m ${s%60}s`;
            const elapsed = hms(Math.max(0, Math.floor(Date.now()/1000 - Number(process.env.START_TS||0))));
            const loc = (Number(process.env.LINES_ADDED||0) + Number(process.env.LINES_REMOVED||0)) + ' LOC';
            const pre = process.env.PRE_FAILED || '0';
            const post = process.env.POST_FAILED || '—';

            const body = (mine.body||'')
              .replace(/Status: .*/, 'Status: ⚠️ Partial fix — some tests still failing')
              .replace(/Failing tests: .*/, `Failing tests: ${pre} → ${post} • Patch size: ${loc} • Elapsed: ${elapsed}`);
            await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body});

      - name: "Label: partial"
        if: ${{ github.event_name == 'pull_request' && steps.nova.outputs.changes_made == 'true' && steps.test_post.outputs.exit_code != '0' }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            try {
              const {data} = await github.rest.issues.listLabelsOnIssue({owner, repo, issue_number});
              for (const L of data) if (L.name.startsWith('nova-')) await github.rest.issues.removeLabel({owner, repo, issue_number, name: L.name}).catch(()=>{});
            } catch {}
            await github.rest.issues.addLabels({owner, repo, issue_number, labels: ['nova-partial']});

      - name: Sticky → failed
        if: ${{ github.event_name == 'pull_request' && steps.nova.outputs.changes_made != 'true' }}
        uses: actions/github-script@v7
        env:
          START_TS: ${{ steps.t0.outputs.ts }}
          PRE_FAILED: ${{ steps.test_pre.outputs.pre_failed || '0' }}
        with:
          script: |
            const anchor = '<!-- NOVA_STICKY_COMMENT -->';
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const mine = comments.find(c => (c.body||'').includes(anchor));
            if (!mine) return;

            const hms = s => `${Math.floor(s/60)}m ${s%60}s`;
            const elapsed = hms(Math.max(0, Math.floor(Date.now()/1000 - Number(process.env.START_TS||0))));
            const pre = process.env.PRE_FAILED || '0';

            const body = (mine.body||'')
              .replace(/Status: .*/, 'Status: ❌ Couldn’t fix (see logs)')
              .replace(/Failing tests: .*/, `Failing tests: ${pre} → — • Patch size: — • Elapsed: ${elapsed}`);
            await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body});

      - name: "Label: failed"
        if: ${{ github.event_name == 'pull_request' && steps.nova.outputs.changes_made != 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const issue_number = context.issue.number || context.payload.pull_request.number;
            try {
              const {data} = await github.rest.issues.listLabelsOnIssue({owner, repo, issue_number});
              for (const L of data) if (L.name.startsWith('nova-')) await github.rest.issues.removeLabel({owner, repo, issue_number, name: L.name}).catch(()=>{});
            } catch {}
            await github.rest.issues.addLabels({owner, repo, issue_number, labels: ['nova-failed']});

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: nova-artifacts-${{ github.run_id }}
          path: |
            test-results.json
            .nova/**
          if-no-files-found: ignore
          retention-days: 7

      - name: Job summary
        if: always()
        run: |
          echo "## 🚀 Nova CI-Rescue Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          PRE_FAILED="${{ steps.pre.outputs.failures || '0' }}"
          FILES_CHANGED="${{ steps.nova.outputs.files_changed || '0' }}"
          LINES_ADDED="${{ steps.nova.outputs.lines_added || '0' }}"
          LINES_REMOVED="${{ steps.nova.outputs.lines_removed || '0' }}"
          DURATION="${{ steps.nova.outputs.duration || 'n/a' }}"
          echo "**🧪 Tests Fixed:** ${PRE_FAILED} → $([[ \"${{ steps.test_post.outputs.exit_code }}\" == '0' ]] && echo 0 || echo '—')" >> $GITHUB_STEP_SUMMARY
          echo "**📈 Patch Size:** ${FILES_CHANGED} files changed, +${LINES_ADDED}/-${LINES_REMOVED} LOC" >> $GITHUB_STEP_SUMMARY
          echo "**⏱ Duration:** ${DURATION}" >> $GITHUB_STEP_SUMMARY
          echo "**🔒 Guardrails:** ≤5 files & ≤100 LOC (demo); never touches main" >> $GITHUB_STEP_SUMMARY
          echo "**🏷 Brand:** ${{ steps.cfg.outputs.BRAND_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "_Never touches main · ≤40 LOC per run · ≤5 files · ≤3 attempts_" >> $GITHUB_STEP_SUMMARY
